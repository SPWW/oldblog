---
layout: post
title:  "learn C++"
date:   2016-01-16 15:28:48 +0800
categories: blog
---

#构造函数和初始化列表

在C++中一切的object都可以理解为是一个class，所以套用class的构造过程，object的创造可以氛围构造和赋值两个阶段，如果在构造函数中完成了初始化赋值，那么就是以一个确定值去初始化，相当于将二者合二为一了。

    int a; \\ 创造一个无初始值的int对象a
    a = 1；\\ 将a的值设置为1

    int a(1); \\ 直接创造一个初始值为1的int类型object a

所以在class中存在数据类型的成员时，创建class的过程，其实也是按照*内部定义顺序*调用内部对象的构造函数的过程。 通常这个过程是隐式的，但是C++中可以通过初始化列表的方式显示调用。所以在初始化一个class对象时如果需要对其设置初始值，最佳的方式应该是通过构造函数直接进行设置。

    class c{
        int a;
        public:
        c(int arga):a(arga){} //直接以arga去初始化a
    }

而不是先创建在赋值

    class c{
        int a;
        public:
        c(int arga){
            a = arga; //对啊赋值arga
        }
    }

#++x和x++

从开始学编程的时候老师就教过：

    ++x是先自增再取值，x++是先取值再自增。

但是，当时一直不能理解对于一个运算符来说取值对应着什么概念，直到开始使用C++的运算符重载，才算是真的把这个问题理清楚。任何一个运算符，我们都可以看做是作用在这个object类型上的一个函数实现。所以自然可以有返回值和函数操作。其他操作看到的运算符作用在object后的结果其实就是这个函数的返回值，而函数体内部当然可以对参数做其他的操作而不返回。结合代码来看自增操作可以是：

    class x{
        int val;
        ...
        public:
        x oprtator++(){         //对应着x++的形式
            x temp = *this;
            this->val += 1;
            return temp;
        }
        x oprtator++(x&){       //对应着++x的形式
            this->val += 1;
            return this->val;
        }
    }

所以看似相同的++符号在前和在后产生了不同的效果，其实了解到内部根本是两种截然不同的实现后就不在意外了。

#==和=

从C语言开始赋值操作沿用了数学中的标识符『=』，而相等判断则用两个等号相连『==』。经常的我们在赋值的时候将一个变量放在左边，一个常量放在右边，对应操作符的左值和右值。因为赋值操作会改变左值的内容所以常量是不能成为左值的，编译器会做出相应的检查。

但是对于「==」操作则没有这种限制，所以在判断语句书写时防止将「=」，「==」搞混最简单的方法就是*在「==」判断中永远将const值放在左边，这样就可以在将「==」误写为「=」时依靠编译器第一时间发现问题*

    int a;

    //这样写即便出错也很难发现
    if(a==0){}
    if(a=0){}

    if(0==a){}
    if(0=a){} \\这样写可以依靠编译器发现错误


